#include "ros/ros.h"
#include "std_msgs/String.h"
#include "std_msgs/Bool.h"
#include "std_srvs/Empty.h"
#include "sensor_msgs/LaserScan.h"
#include "geometry_msgs/Twist.h"
#include "geometry_msgs/Pose2D.h"
#include "geometry_msgs/PoseStamped.h"
#include "geometry_msgs/Quaternion.h"
#include "nav_msgs/Odometry.h"
#include "local_planner_raph/localGoal.h"
#include "local_planner_raph/Path.h"
#include <tf/transform_datatypes.h>

#include <sstream>
#include <iterator>     // std::back_inserter
#include <vector>       // std::vector
#include <algorithm>    // std::copy

using std::vector;
using std::string;
using std::copy;
using std::back_inserter;
using geometry_msgs::Pose2D;

Pose2D iniPose2D;
Pose2D curPose2D;
Pose2D goalPose2D;
bool isObstacle = false;
double zAngSpeed = 0;

vector<geometry_msgs::PoseStamped> pathPoses;

/* TODO :
 - finalisation de la méthode actuelle en ajoutant l'orientation finale
 - nouvelle méthode avec des splines (polynomes 3 ou 5 ??)
 - service avec waypoints de type nav_msgs/Path.msg
 - option : Création de paramètre comme la vitesse lin et ang
 - option : diminution de la vitesse à l'approche d'un obstacle et emission d'un service de blocage après un certain temps


*/


//bool goalCallback(geometry_msgs::Pose2D &goalPose2D, std_msgs::Bool possible )
//bool goalCallback(std_srvs::Empty::Request& request, std_srvs::Empty::Response& response)
bool goalCallback(local_planner_raph::localGoal::Request& request, local_planner_raph::localGoal::Response& response)
{
	response.possible.data = isObstacle?false:true;

	if(!isObstacle) {
		goalPose2D.x = request.goalPose2D.x;
		goalPose2D.y = request.goalPose2D.y;
		goalPose2D.theta = request.goalPose2D.theta;
 	}
		
	return true;
}

bool pathCallback(local_planner_raph::Path::Request& request, local_planner_raph::Path::Response& response)
{

	ROS_INFO("### New path with %d poses", (int)request.pathToGoal.poses.size() );	

    pathPoses.reserve(request.pathToGoal.poses.size());
    copy(request.pathToGoal.poses.rbegin(),request.pathToGoal.poses.rend(),back_inserter(pathPoses));

	ROS_INFO("### New path with %d poses", (int)pathPoses.size() );	

	response.success.data = true;

	return true;
}


void odomCallback(const nav_msgs::Odometry odom)
{
	tf::Quaternion q(	odom.pose.pose.orientation.x, 
						odom.pose.pose.orientation.y, 
						odom.pose.pose.orientation.z, 
						odom.pose.pose.orientation.w);

	tf::Matrix3x3 m(q);
	double roll, pitch, yaw;
	m.getRPY(roll, pitch, yaw);


	curPose2D.x = odom.pose.pose.position.x;
	curPose2D.y = odom.pose.pose.position.y;
	curPose2D.theta = yaw;

	zAngSpeed = odom.twist.twist.angular.z;
/*
  	ROS_INFO("odom: [x = %f] [y = %f] [angle = %f]", 	curPose2D.x,
														curPose2D.y, 
														curPose2D.theta);
*/
}


void scanCallback(const sensor_msgs::LaserScan::ConstPtr& scan)
{
	short scan_size = ((scan->angle_max - scan->angle_min) / scan->angle_increment);
	int i=0;
	//ROS_INFO("### scan->angle_min: %f",  scan->angle_min);
	//ROS_INFO("### scan->angle_max: %f",  scan->angle_max);
	//ROS_INFO("### scan->angle_increment: %f",  scan->angle_increment);

	isObstacle = false;

	for(i=0; i<scan_size; i++)
	{
		if(scan->ranges.at(i) < 0.25) 
		{	
			isObstacle = true;
			ROS_INFO("### OBSTACLE : Distance[%f]   Angle[%f]",  scan->ranges.at(i),  scan->angle_min+(float)i*scan->angle_increment);
		}
	}


	//ROS_INFO("### DISTANCE: [%f]",  scan->ranges.at(scan_size/2) );

}

int main(int argc, char **argv)
{

	ros::init(argc, argv, "planner1");

	ros::NodeHandle n;

	Pose2D nextGoal;
	//Bool isNextGoal;

	ros::Publisher velocity_pub = n.advertise<geometry_msgs::Twist>("cmd_vel_mux/input/navi", 100);
	ros::Subscriber sub1 = n.subscribe("odom", 50, odomCallback);
	ros::Subscriber sub2 = n.subscribe("scan", 100, scanCallback);
	
	ros::ServiceServer service_goal = n.advertiseService("/move_to/singleGoal", goalCallback);
	ros::ServiceServer service_path = n.advertiseService("/move_to/pathGoal", pathCallback);

	goalPose2D.x = 0;
	goalPose2D.y = 0;
	goalPose2D.theta = 0;

	ros::Rate loop_rate(10);

	int count = 0;

	if( pathPoses.size() )
	{
		goalPose2D.x = pathPoses.at( pathPoses.size()-1 ).pose.position.x;
		goalPose2D.y = pathPoses.at( pathPoses.size()-1 ).pose.position.y;
		goalPose2D.theta = pathPoses.at( pathPoses.size()-1 ).pose.orientation.w;
	}

	while (ros::ok())
	{
		geometry_msgs::Twist twist;
		float distance;
		float angle;

		distance = sqrt(pow(goalPose2D.x - curPose2D.x, 2) + pow(goalPose2D.y - curPose2D.y, 2) );
		angle = atan2(goalPose2D.y - curPose2D.y , goalPose2D.x - curPose2D.x) - curPose2D.theta; 

		if(distance < 0.05 && angle < 0.05)
		{	
			if( pathPoses.size() )
			{	
				pathPoses.pop_back();
				if( pathPoses.size() )
				{
					goalPose2D.x = pathPoses.at( pathPoses.size()-1 ).pose.position.x;
					goalPose2D.y = pathPoses.at( pathPoses.size()-1 ).pose.position.y;
					//goalPose2D.theta = pathPoses.at( pathPoses.size()-1 ).pose.orientation.w;
					
					//if( pathPoses.size() >= 2)
					//{				
					//	nextGoal.x = 
				}
				
			}			

			distance = sqrt(pow(goalPose2D.x - curPose2D.x, 2) + pow(goalPose2D.y - curPose2D.y, 2) );
			angle = atan2(goalPose2D.y - curPose2D.y , goalPose2D.x - curPose2D.x) - curPose2D.theta; 
		}

		ROS_INFO("### Pose2d: X=%f Y=%f   theta=%f    ---   distance=%f  angle=%f", goalPose2D.x, goalPose2D.y, goalPose2D.theta, distance, angle);


		//ROS_INFO("### THETA: [%f]",  curPose2D.theta );

		if(angle > 3.141592653589793) angle = fmod(angle, 3.141592653589793);
		if(angle < -3.141592653589793) angle = fmod(angle, 3.141592653589793);

		/*if(distance > 0.1)
		{
			twist.linear.x = distance * 0.25; //(distance > 0.25) ? 0.25 : distance;
			//twist.linear.y = 0.1;
			twist.angular.z = angle * 2.0; //( (angle > 2.0) ? 2.0 : (angle < -2.0) ? -2.0 : angle) * 4.0;// - zAngSpeed * 0.1;
		}
		else if(distance >= 0.01)
		{*/
			//twist.linear.x = distance * 0.25 + twist.linear.x/10.0; //(distance > 0.25) ? 0.25 : distance;
			//twist.linear.y = 0.1;
			twist.angular.z = angle * 2 + twist.angular.z; //( (angle > 2.0) ? 2.0 : (angle < -2.0) ? -2.0 : angle) * 4.0;// - zAngSpeed * 0.1;

			twist.linear.x = (distance > 0.25) ? 0.25 : distance;// + twist.linear.x/10.0; //;
			//twist.linear.y = 0.1;
			//twist.angular.z = ( (angle > 2.0) ? 2.0 : (angle < -2.0) ? -2.0 : angle) * 2.0;// + twist.angular.z; //( (angle > 2.0) ? 2.0 : (angle < -2.0) ? -2.0 : angle) * 4.0;// - zAngSpeed * 0.1;

		/*} else {
			twist.linear.x = 0.0;
			twist.angular.z = goalPose2D.theta - curPose2D.theta;
		}*/

		velocity_pub.publish(twist);

		ros::spinOnce();

		loop_rate.sleep();
		++count;
	}


  return 0;
}
